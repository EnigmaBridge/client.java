package com.enigmabridge.comm;

import javax.crypto.BadPaddingException;

/**
 * PKCS 1.5 padding for RSA operation.
 *
 *  EB = 00 || BT || PS || 00 || D
 *      .. EB = encryption block
 *      .. 00 prefix so EB is not bigger than modulus.
 *      .. BT = 1B block type {00, 01} for private key operation, {02} for public key operation.
 *      .. PS = padding string. Has length k - 3 - len(D).
 *      if BT == 0, then padding consists of 0x0, but we need to know size of data in order to remove padding unambiguously.
 *      if BT == 1, then padding consists of 0xFF.
 *      if BT == 2, then padding consists of randomly generated bytes, does not contain 0x00 byte.
 *      .. D  = data
 *      [https://tools.ietf.org/html/rfc2313 PKCS#1 1.5]
 *
 * Created by dusanklinec on 04.05.16.
 */
public class PKCS1Padding {
    public static byte[] unpad(byte[] buff, int blockLen) throws BadPaddingException {
        return unpad(buff, 0, buff.length, blockLen);
    }

    public static byte[] unpad(byte[] buff, int offset, int len, int blockLen) throws BadPaddingException {
        byte[] res = new byte[blockLen];
        final int written = unpad(buff, offset, len, res, 0, blockLen);

        byte[] res2 = new byte[written];
        System.arraycopy(res, 0, res2, 0, written);
        return res2;
    }

    public static int unpad(byte[] buff, int offset, int len, byte[] out, int outOffset, int blockLen) throws BadPaddingException {
        if (len < 3){
            throw new BadPaddingException("Data is too short");
        }

        // Check the first byte.
        if (buff[offset] != 0x0){
            throw new BadPaddingException("Padding data error, prefix is not 00");
        }

        // BT can be only from set {0,1,2}.
        final short bt = buff[offset+1];
        if (bt != 0 && bt != 1 && bt != 2){
            throw new BadPaddingException("Padding data error, BT is outside of the definition set");
        }

        // Find D in the padded data. Strategy depends on the BT.
        int dataPosStart = -1;
        if (bt == 0){
            // Scan for first non-null character.
            for(int i = 2; i < len; i++){
                if (buff[offset+i] != 0){
                    dataPosStart = offset+i;
                    break;
                }
            }

        } else if (bt == 1){
            // Find 0x0, report failure in 0xff
            boolean ffCorrect = true;
            for(int i = 2; i < len; i++){
                if (buff[offset+i] != 0 && buff[offset+i] != 0xff) {
                    ffCorrect = false;
                }

                if (buff[offset+i] == 0){
                    dataPosStart = offset+i+1;
                    break;
                }
            }

            if (!ffCorrect){
                throw new BadPaddingException("Trail of 0xFF in padding contains also unexpected characters");
            }

        } else {
            // bt == 2, find 0x0.
            for(int i = 2; i < len; i++){
                if (buff[offset+i] == 0){
                    dataPosStart = offset+i+1;
                    break;
                }
            }
        }

        // If data position is out of scope, return nothing.
        if (dataPosStart < 0 || dataPosStart > offset+len){
            throw new BadPaddingException("Padding could not be parsed");
        }

        // Check size of the output buffer.
        int dataLen = offset + len - dataPosStart;
        if (dataLen > blockLen){
            throw new BadPaddingException("Data too big");
        }

        // Copy data from input buffer to output buffer. Do it in a way that in==out, so in-place, non-destructive.
        for(int i = 0; i<dataLen; i++){
            out[outOffset+i] = buff[dataPosStart + i];
        }

        return dataLen;
    }
}
